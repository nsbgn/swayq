// +build ignore
// This tool is not part of the build --- it is an intermediate step that
// produces `builtin.go` by compiling any jq file in the `builtin/` directory
// into an instant Go structure. It runs when you do `go generate`. To remind
// you to keep the jq files and `builtin.go` in lockstep, do:
//    ln -s hooks/pre-commit .git/hooks/pre-commit
// or git config core.hooksPath hooks
//
// Originally adapted from: <https://github.com/itchyny/gojq/blob/0607aa5af33a4f980e3e769a1820db80e3cc7b23/_tools/gen_builtin.go>

package main

import (
	"fmt"
	"go/printer"
	"go/token"
	"os"
	"log"
	"regexp"
	"strings"
	"flag"
	"path/filepath"

	"github.com/itchyny/astgen-go"
	"github.com/itchyny/gojq"
)

func main() {
	var inputDir, outputFile string
	flag.StringVar(&inputDir, "i", "builtin", "input directory")
	flag.StringVar(&outputFile, "o", "-", "output file")
	flag.Parse()
	var out *os.File
	var err error
	if outputFile == "-" {
		out = os.Stdout
	} else {
		out, err = os.Create(outputFile)
		defer out.Close()
	}
	if err != nil {
		log.Fatalln(err)
	}
	out.WriteString(
`// Code generated by go generate; DO NOT EDIT.
// See builtin.generator.go for more information
package main
import . "github.com/itchyny/gojq"
import "github.com/itchyny/gojq"

func LoadBuiltin(name string) *gojq.Query {
	switch(name){
`)

	err = filepath.Walk(inputDir, func(path string, info os.FileInfo, err error) error {
		if info != nil && !info.IsDir() && strings.HasSuffix(path, ".jq") {
			rel, err := filepath.Rel(inputDir, path)
			if err != nil {
				log.Fatalln(err)
			}
			rel = rel[:len(rel)-3]

			cnt, err := os.ReadFile(path)
			if err != nil {
				log.Fatalln(err)
			}
			q, err := gojq.Parse(string(cnt))
			if err != nil {
				log.Fatalln(err)
			}
			for _, fd := range q.FuncDefs {
				fd.Minify()
			}
			str, err := formatQuery(q)
			if err != nil {
				log.Fatalln(err)
			}
			out.WriteString(fmt.Sprintf("\tcase \"%v\":\n\t\treturn ", rel))
			out.WriteString(*str)
			out.WriteString("\n")
		}
		return nil
	})

	out.WriteString(`	default:
		return nil
	}
}`)

	out.WriteString("\n\nfunc listBuiltins() []string {\n\treturn []string{\n")

	err = filepath.Walk(inputDir, func(path string, info os.FileInfo, err error) error {
		if info != nil && !info.IsDir() && strings.HasSuffix(path, ".jq") {
			rel, err := filepath.Rel(inputDir, path)
			if err != nil {
				log.Fatalln(err)
			}
			out.WriteString("\t\t\"")
			out.WriteString(rel[:len(rel)-3])
			out.WriteString("\",\n")
		}
		return nil
	})
	out.WriteString("\t}\n}")

}

func formatQuery(q *gojq.Query) (*string, error) {
	// Get abstract syntax tree of query
	ast, err := astgen.Build(q)
	if err != nil {
		return nil, err
	}

	// Turn AST into a string
	var sb strings.Builder
	err = printer.Fprint(&sb, token.NewFileSet(), ast)
	if err != nil {
		return nil, err
	}
	str := sb.String()

	// Convert integers to proper enums
	for op := gojq.OpPipe; op <= gojq.OpUpdateAlt; op++ {
		re := regexp.MustCompile(fmt.Sprintf(`\b((?:Update)?Op): %d\b`, op))
		str = re.ReplaceAllString(str, fmt.Sprintf("$1: %#v", op))
	}
	for t := gojq.TermTypeIdentity; t <= gojq.TermTypeQuery; t++ {
		re := regexp.MustCompile(fmt.Sprintf(`(Term{Type): %d\b`, t))
		str = re.ReplaceAllString(str, fmt.Sprintf("$1: %#v", t))
	}

	return &str, nil
}
